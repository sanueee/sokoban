# sokoban
coursework "sokoban" made by kahooso &amp; sanueee

---

### **Об игре Sokoban**

Sokoban (яп. 倉庫番, «кладовщик») — классическая японская головоломка, разработанная в 1981 году. Игра представляет собой пошаговую логическую задачу, в которой игрок управляет персонажем, перемещающимся по ограниченному пространству склада или лабиринта. 

Цель игры заключается в том, чтобы переместить все ящики на специально обозначенные целевые позиции. Основная сложность состоит в том, что игрок может только толкать ящики, но не тянуть их. При этом одновременно можно толкать только один ящик. Ящик, загнанный в угол или неправильную позицию, может сделать уровень нерешаемым, что требует от игрока стратегического планирования каждого хода.

---

### **Концепция разрабатываемой версии**

Данный проект представляет собой современную реализацию классической игры Sokoban на языке C с использованием структурно-функциональной парадигмы программирования. Разрабатываемая версия сочетает традиционную механику оригинальной игры с современными удобствами и минималистичным визуальным стилем, вдохновленным японской эстетикой.

**Визуальная концепция:**
Графическое оформление выполнено в стиле 2D пиксель-арта с использованием цветовой палитры из цветов: красный, черный, белый, розовый, бирюзовый. Игровые объекты стилизованы под элементы японской культуры: персонаж представлен в виде маленького самурая или ниндзя, ящики оформлены как традиционные японские фонарики или бочки, фон содержит минималистичные паттерны (волны, цветы сакуры, решетки сёдзи).

---

### **Функциональные возможности**

**1. Игровой процесс**

- **Система уровней:** Игра содержит 5 уникальных уровней возрастающей сложности, от обучающего до экспертного
- **Управление персонажем:** Перемещение осуществляется с помощью клавиш клавиатуры (WASD или стрелки направлений)
- **Механика толкания:** Реализована базовая механика толкания ящиков с проверкой коллизий и допустимости хода
- **Проверка победы:** Автоматическое определение завершения уровня при размещении всех ящиков на целевых позициях

**2. Система отмены ходов (Undo)**

- Возможность отмены произвольного количества ходов
- Реализация через стек состояний игры
- Позволяет экспериментировать с решениями без необходимости полного перезапуска уровня

**3. Статистика и отслеживание прогресса**

- **Счетчик шагов:** Подсчет количества перемещений игрока
- **Счетчик толчков:** Отдельный учет количества перемещений ящиков
- **Таймер:** Отслеживание времени прохождения уровня
- Отображение текущей статистики в игровом интерфейсе

**4. Система сохранения**

- Сохранение прогресса прохождения уровней
- Запись лучших результатов (минимальное количество шагов, лучшее время)
- Хранение данных в текстовых файлах для удобства отладки

**5. Пользовательский интерфейс**

- Главное меню с выбором уровня
- Экран паузы с возможностью перезапуска уровня или выхода
- Экран завершения уровня с отображением итоговой статистики
- Визуальная индикация целевых позиций и успешно размещенных ящиков

---

### **Технические характеристики**

**Язык программирования:** C (стандарт ???)

**Архитектура проекта:**
Проект построен на структурно-функциональной парадигме с четким разделением ответственности между модулями:
- Модуль игровой логики (обработка ходов, проверка правил)
- Модуль управления уровнями (загрузка, хранение данных уровней)
- Модуль рендеринга (графический вывод)
- Модуль обработки ввода (взаимодействие с пользователем)
- Модуль сохранения/загрузки данных

---

### **ТЗ**

При запуске игры нас встречает главное меню в котором представлен функционал игры: 
    - возможность закрыть приложение (крестик в углу)
    - возможность посмотреть статистику собранную на основе предыдущих игр (сделаем бдшку)
    - возможность выключить/включить звук (только музыка - по умолчанию включена)
    - возможность посмотреть правила/цель игры и способы управления персонажем (краткая сводка правил, управление через WASD и стрелки)
    - возможность сгенерировать и сыграть в сокобан
    ...

### **Генерация уровней**

**Общий подход**

Для автоматической генерации решаемых уровней используется метод **обратной генерации** (reverse solving), который гарантирует решаемость каждого созданного уровня без необходимости применения ресурсоёмких алгоритмов проверки.

**Алгоритм генерации**

1. Инициализация

    Вход: 
    - Размер поля (ширина × высота)
    - Количество ящиков N
    - Целевая сложность (количество шагов в решении)

    Выход:
    - Валидный решаемый уровень

2. Этапы генерации

Этап 1: Создание базовой структуры
    - Генерация случайного лабиринта стен методом клеточного автомата или рекурсивного backtracking
    - Обеспечение связности игрового пространства (все клетки достижимы)
    - Размещение N целевых позиций в случайных точках поля

Этап 2: Установка решённого состояния
    - Размещение всех N ящиков на целевых позициях
    - Размещение игрока в произвольной свободной клетке
    - Это состояние является решением уровня

Этап 3: Обратное решение (Reverse Solving)

Для i = 1 до TARGET_MOVES:
    1. Выбрать случайный ящик, который можно "оттолкнуть"
    2. Проверить, что за ящиком есть свободное место для игрока
    3. Переместить ящик в обратном направлении
    4. Обновить позицию игрока
    5. Сохранить состояние

Этап 4: Валидация
    - Проверка отсутствия простых тупиковых ситуаций (ящики в углах вне целей)
    - Проверка достижимости всех ящиков игроком
    - Опционально: быстрая проверка решаемости упрощённым солвером

Этап 5: Финализация
    - Полученное состояние становится начальным уровнем
    - Сохранение в файловом формате или базе данных

Параметры сложности

| Уровень сложности | Размер поля | Кол-во ящиков | Целевые шаги |
|-------------------|-------------|---------------|--------------|
| Лёгкий            | 8×8 - 10×10 | 3-4           | 15-30        |
| Средний           | 12×12 - 14×14| 5-6          | 40-70        |
| Сложный           | 15×15 - 18×18| 7-8          | 80-120       |

**Оптимизации**

**Предотвращение тривиальных уровней:**
    - Контроль минимального расстояния между ящиками
    - Запрет на последовательное толкание одного ящика >5 раз
    - Добавление случайности в выбор направлений

**Обеспечение разнообразия:**
    - Чередование открытых пространств и узких коридоров
    - Вариация расположения целевых зон (кластеры vs распределённые)
    - Использование seed-значений для воспроизводимости

**Гарантии корректности**

Метод обратной генерации обеспечивает:
    1. **Решаемость**: каждый уровень имеет как минимум одно решение (обратная последовательность ходов)
    2. **Предсказуемую сложность**: количество шагов в решении контролируется параметром TARGET_MOVES
    3. **Отсутствие deadlock**: на начальном этапе ящики находятся в решённом состоянии

**Ограничения метода**

    - Генерируемые уровни могут быть менее интересными, чем ручной дизайн
    - Алгоритм склонен создавать "линейные" решения с последовательным перемещением ящиков
    - Требуется постобработка для улучшения визуального разнообразия

---

## Процесс прохождения уровня

### Инициализация уровня

После успешной генерации уровня система выполняет следующие действия:

1. **Загрузка состояния**
   - Размещение игрока в стартовой позиции
   - Расстановка ящиков согласно сгенерированной конфигурации
   - Отображение целевых позиций (goals)
   - Инициализация счётчиков (шаги, время)

2. **Отображение интерфейса**
   - Рендеринг игрового поля
   - Вывод информации о текущем уровне (номер, сложность)
   - Отображение статистики: количество шагов, затраченное время
   - Индикация оставшихся ящиков вне целей
   - Запуск фоновой музыки (если включена в настройках)

### Игровой цикл (Game Loop)

```
ПОКА уровень не завершён:
    1. Ожидание пользовательского ввода
    2. Обработка команды
    3. Валидация хода
    4. Обновление игрового состояния
    5. Перерисовка сцены
    6. Проверка условия победы
```

### Система управления

#### Клавиатурный ввод

| Клавиша       | Действие                          |
|---------------|-----------------------------------|
| ↑ / W         | Движение вверх                    |
| ↓ / S         | Движение вниз                     |
| ← / A         | Движение влево                    |
| → / D         | Движение вправо                   |
| Ctrl+Z        | Отмена последнего хода                |
| R             | Перезапуск уровня                 |
| ESC           | Пауза / возврат в меню            | (при паузе скрывается текущий уровень)

### Логика обработки хода

```
При нажатии клавиши направления:
    
    1. Определить целевую клетку (player_x + dx, player_y + dy)
    
    2. ЕСЛИ целевая клетка - стена:
         → Отменить движение
         → Краткая анимация столкновения
         → ВЫХОД
    
    3. ЕСЛИ целевая клетка - пустое пространство:
         → Переместить игрока
         → Увеличить счётчик шагов
         → Сохранить состояние в стек отмены (максимум 512 ходов)
         → ВЫХОД
    
    4. ЕСЛИ целевая клетка - ящик:
         a. Определить клетку за ящиком (box_x + dx, box_y + dy)
         
         b. ЕСЛИ клетка за ящиком занята (стена/другой ящик):
              → Отменить движение
              → Краткая анимация блокировки (опционально)
              → ВЫХОД
         
         c. ИНАЧЕ:
              → Переместить игрока на клетку ящика
              → Переместить ящик на следующую клетку
              → Увеличить счётчик шагов
              → Сохранить состояние в стек отмены
              
              ЕСЛИ ящик теперь на цели:
                  → Анимация попадания на цель
                  → Визуальная индикация успеха
              
              ЕСЛИ ящик больше не на цели:
                  → Стандартная анимация толкания
              
              → ВЫХОД
```

### Система отмены ходов (Undo)

**Структура данных:**
```c
typedef struct {
    int player_x, player_y;
    Box boxes[MAX_BOXES];
    int step_count;
} GameState;

Stack<GameState> undo_stack;  // стек предыдущих состояний
```

**Алгоритм отмены:**
При нажатии Z:
    ЕСЛИ стек отмены не пуст:
        1. Извлечь предыдущее состояние из стека
        2. Восстановить позицию игрока
        3. Восстановить позиции всех ящиков
        4. Уменьшить счётчик шагов
        5. Анимация обратного перемещения (опционально)
        6. Перерисовать сцену

**Ограничения:**
- Максимальная глубина отмены: последние 512 ходов
- При перезапуске уровня стек очищается

### Условия завершения уровня

#### Победа

```
Проверка после каждого хода:
    
    boxes_on_goals = 0
    
    ДЛЯ КАЖДОГО ящика:
        ЕСЛИ (box.x, box.y) == одна из целевых позиций:
            boxes_on_goals++
    
    ЕСЛИ boxes_on_goals == total_boxes:
        → ПОБЕДА
```

**Действия при победе:**
1. Остановка таймера
2. Вычисление финальной статистики:
   - Общее количество шагов
   - Время прохождения
   - Эффективность (сравнение с оптимальным решением, если известно)
3. Воспроизведение победной анимации
4. Отображение экрана завершения уровня
5. Сохранение результата в базу данных
6. Предложение перейти к следующему уровню

#### Тупиковая ситуация (Deadlock)

Система может автоматически обнаруживать нерешаемые состояния. Простая проверка deadlock.


### Отображение информации

**HUD:**
```
┌─────────────────────────────┐
│ Уровень: 3 (Средний)        │
│ Шаги: 47                    │
│ Время: 02:34                │
│ Ящиков на целях: 4/6        │
└─────────────────────────────┘
```

**Визуальная обратная связь:**
- Ящик на цели: зелёная подсветка / галочка
- Ящик вне цели: обычный вид
- Игрок: анимация движения при перемещении
- Толкание ящика: плавная анимация сдвига

### Система сохранения прогресса

#### Структура базы данных

**Таблица: game_sessions**
```sql
CREATE TABLE game_sessions (
    session_id INTEGER PRIMARY KEY AUTOINCREMENT,
    level_id INTEGER NOT NULL,
    player_x INTEGER NOT NULL,
    player_y INTEGER NOT NULL,
    boxes_data TEXT NOT NULL,  -- "5,7;6,8;4,9;..."
    step_count INTEGER DEFAULT 0,
    time_elapsed INTEGER DEFAULT 0,  -- в секундах
    start_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_completed BOOLEAN DEFAULT 0
);
```

**Таблица: level_statistics**
```sql
CREATE TABLE level_statistics (
    stat_id INTEGER PRIMARY KEY AUTOINCREMENT,
    level_id INTEGER NOT NULL,
    total_steps INTEGER NOT NULL,
    completion_time INTEGER NOT NULL,  -- в секундах
    completion_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
);
```

#### Операции с БД

**Автосохранение при каждом ходе:**
```c
void save_game_state(GameSession* session) {
    // Обновление основной сессии
    sqlite3_exec(db, 
        "UPDATE game_sessions SET "
        "player_x = ?, player_y = ?, step_count = ?, "
        "time_elapsed = ?, last_updated = CURRENT_TIMESTAMP "
        "WHERE session_id = ?", ...);
    
    // Удаление старых позиций ящиков
    sqlite3_exec(db, 
        "DELETE FROM box_states WHERE session_id = ?", ...);
    
    // Сохранение текущих позиций ящиков
    for (int i = 0; i < num_boxes; i++) {
        sqlite3_exec(db,
            "INSERT INTO box_states (session_id, box_index, x, y) "
            "VALUES (?, ?, ?, ?)", ...);
    }
}
```

**Загрузка при запуске:**
```c
GameSession* load_game_state(int session_id) {
    // Загрузка основных данных сессии
    sqlite3_exec(db,
        "SELECT player_x, player_y, step_count, time_elapsed "
        "FROM game_sessions WHERE session_id = ? AND is_completed = 0", ...);
    
    // Загрузка позиций ящиков
    sqlite3_exec(db,
        "SELECT box_index, x, y FROM box_states "
        "WHERE session_id = ? ORDER BY box_index", ...);
    
    return session;
}
```

**Сохранение результата при победе:**
```c
void save_completion_stats(int level_id, int steps, int time) {
    // Отметить сессию как завершённую
    sqlite3_exec(db,
        "UPDATE game_sessions SET is_completed = 1 "
        "WHERE session_id = ?", ...);
    
    // Сохранить статистику
    sqlite3_exec(db,
        "INSERT INTO level_statistics "
        "(level_id, total_steps, completion_time) "
        "VALUES (?, ?, ?)", ...);
    
    // Обновить общий прогресс
    sqlite3_exec(db,
        "UPDATE player_progress SET "
        "highest_level_completed = MAX(highest_level_completed, ?), "
        "total_levels_completed = total_levels_completed + 1, "
        "total_playtime = total_playtime + ?", ...);
}
```

**Запрос лучших результатов:**
```c
void get_best_scores(int level_id) {
    sqlite3_exec(db,
        "SELECT MIN(total_steps) as best_steps, "
        "MIN(completion_time) as best_time "
        "FROM level_statistics WHERE level_id = ?", ...);
}
```

### Переход между уровнями

**После победы:**
1. Отображение статистики текущего уровня
2. Сравнение с личными рекордами из БД
3. Кнопки действий:
   - "Следующий уровень" → генерация/загрузка уровня N+1
   - "Переиграть" → перезапуск текущего уровня с созданием новой сессии
   - "Главное меню" → выход с сохранением прогресса

**Отслеживание прогресса:**
- При запуске игры система проверяет `highest_level_completed` в БД
- Игрок может начать с любого пройденного уровня
- Непройденные уровни блокируются

---



