# Техническое задание: Sokoban

**Авторы:** kahooso & sanueee  
**Язык:** C (стандарт C11)  
**Графическая библиотека:** raylib  
**СУБД:** SQLite3  
**Версия ТЗ:** 2.0

---

## 1. Об игре

Sokoban (яп. 倉庫番, «кладовщик») — классическая японская головоломка, разработанная в 1981 году. Игрок управляет персонажем, перемещающимся по ограниченному пространству. Цель — переместить все ящики на целевые позиции. Игрок может только толкать ящики (не тянуть), причём одновременно — только один ящик.

---

## 2. Концепция

Современная реализация Sokoban на C с процедурной генерацией уровней, 2D-графикой и сохранением статистики в SQLite.

**Визуальный стиль:** простая 2D-графика. Цветовая палитра: красный, чёрный, белый, розовый, бирюзовый.

**Музыка и звуки:** только музыка с возможностью отключения.

---

## 3. Функциональные возможности

### 3.1. Главное меню

При запуске игры отображается главное меню со следующими пунктами:

- **Новая игра** — выбор сложности (Лёгкий / Средний / Сложный), затем генерация и запуск уровня
- **Статистика** — просмотр статистики прохождений из базы данных (лучшие результаты по каждой сложности)
- **Правила** — экран с описанием правил игры и управления
- **Выход** — закрытие приложения (также доступно через крестик окна)

Все уровни сложности доступны сразу.

### 3.2. Генерация уровней

Игра содержит три уровня сложности. Уровни генерируются автоматически на основе случайных параметров из диапазона:

| Уровень сложности | Размер поля   | Кол-во ящиков | Целевые шаги |
|-------------------|---------------|---------------|--------------|
| Лёгкий            | 8×8 – 10×10   | 3–4           | 15–30        |
| Средний           | 12×12 – 14×14 | 5–6           | 40–70        |
| Сложный           | 15×15 – 18×18 | 7–8           | 80–120       |

При выборе сложности параметры (размер поля, количество ящиков, целевое количество шагов) выбираются случайно из соответствующего диапазона.

### 3.3. Игровой процесс

- **Управление персонажем:** WASD или стрелки
- **Механика толкания:** игрок может толкать один ящик за раз; толкание двух ящиков или толкание в стену невозможно
- **Проверка победы:** автоматическое определение завершения при размещении всех ящиков на целевых позициях
- **Обнаружение тупиков (deadlock):** если ящик оказался в неразрешимой позиции, система уведомляет игрока (подробнее в разделе 5.5)

### 3.4. Система отмены ходов (Undo)

- Отмена по нажатию клавиши **Z**
- Реализация через стек состояний
- Максимальная глубина: **512 ходов**
- При перезапуске уровня стек очищается

### 3.5. Статистика в процессе игры (HUD)

Во время прохождения отображается:

- Уровень сложности
- Количество сделанных шагов
- Время прохождения (таймер)
- Количество ящиков на целях / общее количество ящиков

### 3.6. Система сохранения

- Статистика завершённых уровней сохраняется в SQLite
- Сохраняются: сложность, количество шагов, время прохождения, дата
- Экран статистики показывает лучшие результаты по каждой сложности (минимум шагов, лучшее время)
- Сохранение текущего состояния (mid-game save) происходит при выходе из игры или при паузе, а не на каждый ход

---

## 4. Алгоритм генерации уровней

### 4.1. Общий подход

Используется метод **обратной генерации** (reverse solving), гарантирующий решаемость каждого уровня.

### 4.2. Алгоритм генерации карты

**Этап 1: Создание игрового пространства**

Вместо классического лабиринта используется алгоритм, создающий открытые пространства с коридорами:

1. Создать поле заданного размера, заполненное стенами
2. Выбрать случайную стартовую точку внутри поля (не на границе)
3. Методом случайного блуждания (random walk) «выкопать» свободные клетки:
   - Из текущей позиции выбрать случайное направление
   - Переместиться на 1 клетку, отметив её как свободную
   - Повторять, пока количество свободных клеток не достигнет ~55–65% от площади поля (за вычетом границ)
4. Границы поля всегда остаются стенами
5. Проверить связность свободного пространства (flood fill от стартовой точки). Если не все свободные клетки достижимы — повторить генерацию

Результат: открытое пространство с естественными коридорами и нишами, подходящее для Sokoban.

**Этап 2: Установка решённого состояния**

1. Разместить N целевых позиций в случайных свободных клетках (с минимальным расстоянием 2 клетки между ними)
2. Поставить все N ящиков на целевые позиции
3. Поставить игрока в случайную свободную клетку

**Этап 3: Обратное решение (Reverse Solving)**

```
ДЛЯ i = 1 ДО TARGET_MOVES:
    1. Выбрать случайный ящик
    2. Выбрать случайное направление
    3. Проверить, что:
       - Клетка за ящиком (в обратном направлении) свободна (не стена, не ящик)
       - Клетка, откуда «тянут» ящик (позиция для игрока), свободна
    4. Если проверки пройдены:
       - Переместить ящик в обратном направлении
       - Поставить игрока на позицию, откуда он «толкнул бы» ящик
    5. Если не пройдены — попробовать другой ящик/направление
    6. Не толкать один и тот же ящик более 5 раз подряд
```

**Этап 4: Валидация**

- Проверить, что ни один ящик не находится в deadlock-позиции (см. раздел 5.5)
- Проверить, что все ящики достижимы игроком (flood fill)
- Если валидация не пройдена — перегенерировать уровень

**Этап 5: Финализация**

- Полученное состояние становится начальным уровнем
- Обратная последовательность ходов является гарантированным решением

### 4.3. Оптимизации

- Минимальное расстояние между целевыми позициями — 2 клетки
- Запрет на последовательное толкание одного ящика более 5 раз
- Случайный выбор направлений для разнообразия

---

## 5. Игровая логика

### 5.1. Обработка хода

```
При нажатии клавиши направления:

    1. Определить целевую клетку: (player_x + dx, player_y + dy)

    2. ЕСЛИ целевая клетка — стена:
        → Анимация столкновения
         → Ход отменяется        

    3. ЕСЛИ целевая клетка — пустое пространство или цель без ящика:
         → Сохранить текущее состояние в стек отмены
         → Переместить игрока
         → Увеличить счётчик шагов

    4. ЕСЛИ целевая клетка содержит ящик:
         a. Определить клетку за ящиком: (box_x + dx, box_y + dy)
         b. ЕСЛИ клетка за ящиком занята (стена или другой ящик):
              → Ход отменяется
         c. ИНАЧЕ:
              → Сохранить текущее состояние в стек отмены
              → Переместить ящик на следующую клетку
              → Переместить игрока на клетку ящика
              → Увеличить счётчик шагов
              → Проверить deadlock (раздел 5.5)

    5. Проверить условие победы
```

### 5.2. Проверка победы

```
После каждого хода:

    boxes_on_goals = 0

    ДЛЯ КАЖДОГО ящика:
        ЕСЛИ позиция ящика совпадает с одной из целевых позиций:
            boxes_on_goals++

    ЕСЛИ boxes_on_goals == total_boxes:
        → ПОБЕДА
```

### 5.3. Действия при победе

1. Остановить таймер
2. Отобразить экран завершения с итоговой статистикой (шаги, время)
3. Сохранить результат в базу данных
4. Предложить кнопки:
   - **Новый уровень** — генерация нового уровня той же сложности
   - **Переиграть** — перезапуск текущего уровня
   - **Главное меню** — возврат в меню

### 5.4. Система отмены (Undo)

```c
typedef struct {
    int player_x, player_y;
    int boxes[MAX_BOXES][2];  // позиции всех ящиков [x, y]
    int step_count;
} GameState;
```

Стек `GameState undo_stack[512]` хранит до 512 предыдущих состояний.

При нажатии **Z**:
1. Если стек не пуст — извлечь последнее состояние
2. Восстановить позицию игрока и всех ящиков
3. Восстановить счётчик шагов
4. Перерисовать сцену

### 5.5. Обнаружение тупиков (Deadlock Detection)

После каждого перемещения ящика проверяются следующие условия:

**1. Corner deadlock (ящик в углу):**
Если ящик не на целевой позиции и заблокирован стенами по двум смежным осям (например, стена сверху И стена слева) — это deadlock.

```
Проверить 4 варианта углов:
    (стена_сверху И стена_слева)
    (стена_сверху И стена_справа)
    (стена_снизу И стена_слева)
    (стена_снизу И стена_справа)

Если любой из них истинен И ящик НЕ на цели → deadlock
```

**2. Wall deadlock (ящик у стены без цели):**
Если ящик прижат к стене (горизонтальной или вертикальной), и вдоль этой стены нет ни одной целевой позиции — ящик никогда не будет размещён на цели.

```
ЕСЛИ ящик прижат к стене по оси X (стена сверху или снизу):
    Проверить все клетки вдоль этой стены
    ЕСЛИ ни одна из них не является целевой позицией → deadlock

Аналогично для оси Y
```

При обнаружении deadlock — показать уведомление игроку с предложением отменить ход (Z) или перезапустить уровень (R).

---

## 6. Управление

| Клавиша       | Действие                          |
|---------------|-----------------------------------|
| ↑ / W         | Движение вверх                    |
| ↓ / S         | Движение вниз                     |
| ← / A         | Движение влево                    |
| → / D         | Движение вправо                   |
| Z             | Отмена последнего хода            |
| R             | Перезапуск уровня                 |
| ESC           | Пауза / возврат в меню            |

---

## 7. Пользовательский интерфейс

### 7.1. Главное меню

- Название игры
- Кнопки: Новая игра, Статистика, Правила, Выход
- При нажатии «Новая игра» — экран выбора сложности (Лёгкий / Средний / Сложный)

### 7.2. Игровой экран

- Игровое поле в центре окна
- HUD сверху или сбоку:
  ```
  Сложность: Средний
  Шаги: 47
  Время: 02:34
  Ящики: 4/6
  ```
- Ящик на цели: отображается другим цветом (например, зелёным)
- Ящик вне цели: обычный цвет

### 7.3. Экран паузы (ESC)

- Продолжить
- Перезапустить уровень
- Новый уровень (перегенерация той же сложности)
- Выйти в меню (с сохранением автоматически)

### 7.4. Экран завершения уровня

- Итоговая статистика: шаги, время
- Сравнение с лучшим результатом из БД
- Кнопки: Новый уровень / Переиграть / Главное меню

### 7.5. Экран статистики

- Таблица лучших результатов по каждой сложности (топ-5 или топ-10)
- Столбцы: №, шаги, время, дата

### 7.6. Экран правил

- Краткое описание цели игры
- Список управления (WASD / стрелки / Z / R / ESC )

---

## 8. Окно и рендеринг

- **Начальный размер окна:** 800×600 пикселей
- **Окно растягиваемое:** пользователь может менять размер; игровое поле масштабируется, сохраняя пропорции
- **Размер тайла:** вычисляется динамически как `min(доступная_ширина / cols, доступная_высота / rows)`, чтобы поле вмещалось в окно
- **FPS:** 30
- **Рендеринг:** с текстурами и анимациями todo

### Цветовая схема 

todo

---

## 9. База данных (SQLite)

### 9.1. Схема

**Таблица: game_sessions** — текущие/незавершённые сессии

```sql
CREATE TABLE game_sessions (
    session_id    INTEGER PRIMARY KEY AUTOINCREMENT,
    difficulty    TEXT NOT NULL,              -- 'easy', 'medium', 'hard'
    field_width   INTEGER NOT NULL,
    field_height  INTEGER NOT NULL,
    player_x      INTEGER NOT NULL,
    player_y      INTEGER NOT NULL,
    boxes_data    TEXT NOT NULL,              -- позиции ящиков: "x1,y1;x2,y2;..."
    goals_data    TEXT NOT NULL,              -- позиции целей: "x1,y1;x2,y2;..."
    walls_data    TEXT NOT NULL,              -- позиции стен: "x1,y1;x2,y2;..."
    step_count    INTEGER DEFAULT 0,
    time_elapsed  INTEGER DEFAULT 0,         -- в секундах
    is_completed  INTEGER DEFAULT 0,
    created_at    DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at    DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**Таблица: level_statistics** — завершённые прохождения

```sql
CREATE TABLE level_statistics (
    stat_id          INTEGER PRIMARY KEY AUTOINCREMENT,
    difficulty       TEXT NOT NULL,           -- 'easy', 'medium', 'hard'
    total_steps      INTEGER NOT NULL,
    completion_time  INTEGER NOT NULL,        -- в секундах
    completed_at     DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 9.2. Операции

**Сохранение при паузе/выходе:**

```sql
INSERT OR REPLACE INTO game_sessions
    (difficulty, field_width, field_height, player_x, player_y,
     boxes_data, goals_data, walls_data, step_count, time_elapsed)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
```

**Сохранение при победе:**

```sql
-- Отметить сессию как завершённую
UPDATE game_sessions SET is_completed = 1 WHERE session_id = ?;

-- Сохранить статистику
INSERT INTO level_statistics (difficulty, total_steps, completion_time)
VALUES (?, ?, ?);
```

**Загрузка незавершённой сессии при запуске:**

```sql
SELECT * FROM game_sessions
WHERE is_completed = 0
ORDER BY updated_at DESC
LIMIT 1;
```

**Получение лучших результатов:**

```sql
SELECT total_steps, completion_time, completed_at
FROM level_statistics
WHERE difficulty = ?
ORDER BY total_steps ASC
LIMIT 10;
```

---

## 10. Архитектура проекта

### 10.1. Структура файлов

```
sokoban/
├── src/
│   ├── main.c              — точка входа, главный цикл
│   ├── game.h / game.c     — игровая логика (ходы, undo, победа, deadlock)
│   ├── level.h / level.c   — генерация уровней
│   ├── render.h / render.c — рендеринг (поле, HUD, меню)
│   ├── ui.h / ui.c         — UI-экраны (меню, пауза, статистика, правила)
│   ├── db.h / db.c         — работа с SQLite (сохранение, загрузка, статистика)
│   └── types.h             — общие типы и константы
├── CMakeLists.txt
├── README.md
└── sokoban.db              — создаётся автоматически при первом запуске
```

### 10.2. Основные структуры данных

```c
#define MAX_BOXES 10
#define MAX_UNDO 512
#define MAX_FIELD 20

typedef enum {
    CELL_FLOOR,
    CELL_WALL
} CellType;

typedef enum {
    SCREEN_MENU,
    SCREEN_DIFFICULTY,
    SCREEN_GAME,
    SCREEN_PAUSE,
    SCREEN_WIN,
    SCREEN_STATS,
    SCREEN_RULES
} Screen;

typedef enum {
    DIFF_EASY,
    DIFF_MEDIUM,
    DIFF_HARD
} Difficulty;

typedef struct {
    int x, y;
} Position;

typedef struct {
    Position player;
    Position boxes[MAX_BOXES];
    int step_count;
} GameState;

typedef struct {
    int width, height;
    CellType cells[MAX_FIELD][MAX_FIELD];
    Position goals[MAX_BOXES];
    int num_boxes;
    Position boxes[MAX_BOXES];
    Position player;
    Difficulty difficulty;
    int step_count;
    float time_elapsed;
    GameState undo_stack[MAX_UNDO];
    int undo_top;
} Level;
```

### 10.3. Главный цикл

```c
int main(void) {
    // Инициализация raylib (800x600, resizable, 30 FPS)
    // Инициализация SQLite
    // Проверка незавершённой сессии

    Screen current_screen = SCREEN_MENU;

    while (!WindowShouldClose()) {
        // Обработка ввода в зависимости от текущего экрана
        // Обновление состояния
        // Рендеринг
    }

    // Сохранение при выходе (если игра в процессе)
    // Закрытие SQLite
    // Закрытие raylib
}
```

---

## 11. Сборка

Проект собирается через CMake. Зависимости: raylib, sqlite3.

```bash
mkdir build && cd build
cmake ..
make
./sokoban
```

---
